# Экзамен по сетям

---

## Оглавление

- [IP пакет, структура IP пакета](#ip-пакет-структура-ip-пакета)
- [IP маршрутизация, упрощённая таблица маршрутизации, таблица маршрутизации конечного хоста](#ip-маршрутизация-упрощённая-таблица-маршрутизации-таблица-маршрутизации-конечного-хоста)
- [IP маршрутизация: без масок, на основе масок](#ip-маршрутизация-без-масок-на-основе-масок)
- [Схема протоколов модели OSI](#схема-протоколов-модели-osi)
- [Протокол ICMP, структура кадра, типы сообщений, коды ошибок](#протокол-icmp-структура-кадра-типы-сообщений-коды-ошибок)
- [Протоколы TCP/UDP мультиплексировени и демультиплексирование, сокеты](#протоколы-tcpudp-мультиплексировени-и-демультиплексирование-сокеты)
- [Протокол UDP, структура кадра](#протокол-udp-структура-кадра)
- [Протокол TCP, структура кадра, схема логического содеинения в TCP](#протокол-tcp-структура-кадра-схема-логического-содеинения-в-tcp)
- [Протокол TCP, схма состояний](#протокол-tcp-схма-состояний)
- [Классификация протоколов маршрутизации](#классификация-протоколов-маршрутизации)
- [Протокол RIP, время жизни пакетов, зацикливание пакетов](#протокол-rip-время-жизни-пакетов-зацикливание-пакетов)
- [Протокол BGP](#протокол-bgp)
- [Общие принципы построения служб](#общие-принципы-построения-служб)
- [URI, URL, URN](#uri-url-urn)
- [Протокол HTTP, веб-клиент, веб-сервер, заголовки, cookie](#протокол-http-веб-клиент-веб-сервер-заголовки-cookie)
- [Протоколы TLS, SSL](#протоколы-tls-ssl)
- [Протокол FTP](#протокол-ftp)
- [Почтовая служба, протоколы POP и IMAP](#почтовая-служба-протоколы-pop-и-imap)
- [Протокол DNS](#протокол-dns)
- [Протоколы IPv5 и IPv6. Стркуктрура даресов IPv6](#протоколы-ipv5-и-ipv6-стркуктрура-даресов-ipv6)
- [Формат пакета IPv6](#формат-пакета-ipv6)
- [Архитектура безпроводных сетей](#архитектура-безпроводных-сетей)
- [Стек протоколов и стандарты IEEE 802.11](#стек-протоколов-и-стандарты-ieee-80211)
- [Формат кадра в стандарте IEEE 802.11](#формат-кадра-в-стандарте-ieee-80211)
- [Процедура присоединения устройств в IEEE 802.11](#процедура-присоединения-устройств-в-ieee-80211)
- [Работа proxy и NAT](#работа-proxy-и-nat)
- [Фаервол, основные функции, классификация](#фаервол-основные-функции-классификация)
- [Фаервол - схема настройки и фильтрации пакетов](#фаервол---схема-настройки-и-фильтрации-пакетов)
- [Определение и принципы работы WAF, NGFW, UTM](#определение-и-принципы-работы-waf-ngfw-utm)
- [Структура правила snort](#структура-правила-snort)
- [Атака TCP syn flood](#атака-tcp-syn-flood)
- [Атака TCP syn-`ACK` flood](#атака-tcp-syn-`ACK`-flood)
- [Атаки TCP rst\`FIN` flood](#атаки-tcp-rst`FIN`-flood)
- [Атака фраментированный ICMP\UDP flood, атака Ping Of Death](#атака-фраментированный-icmpudp-flood-атака-ping-of-death)
- [Атака ARP-spoo`FIN`g](#атака-arp-spoo`FIN`g)

---

## IP пакет, структура IP пакета

Протокол IP относится к протоколам _без установления соединений_, поддерживая обработку
каждого IP-пакета как независимой единицы обмена, не связанной с другими пакетами.
В протоколе IP нет механизмов, обычно применяемых для обеспечения достоверности
конечных данных. Если во время продвижения пакета происходит какая-либо ошибка, то
протокол IP по своей инициативе ничего не предпринимает для ее исправления. Протокол IP реализует политику доставки «по
возможности».

### Структура IP пакета:

* `Номер версии` занимает 4 бита и идентифицирует версию протокола IP. (IPv4, IPv6)
* `Длина заголовка` занимает 4 бита и и измеряется в 32-битных
  словах. Обычно заголовок имеет длину в 20 байт (пять 32-битных слов), но при добавлении некоторой служебной информации
  это значение может быть увеличено за счет дополнительных байтов в поле параметров. Наибольшая длина заголовка
  составляет 60 байт.
* `Тип сервиса (Type of Service, ToS)` имеет и другое, более современное название —
  `байт дифференцированного обслуживания`, или` DS-байт`. Поле служит для хранения признаков, отражающих требования к
  качеству обслуживания пакета.
    * В прежнем варианте первые три бита содержат значение приоритета пакета: от самого
      низкого — 0 до самого высокого — 7. Маршрутизаторы и компьютеры могут принимать
      во внимание приоритет пакета и обрабатывать более важные пакеты в первую очередь.
    * Следующие три бита поля `ToS` определяют критерий выбора маршрута. Если для бита `D
      (Delay — задержка)` установлено значение 1, то маршрут должен выбираться для минимизации задержки доставки данного
      пакета.
    * Установленный бит `T (Throughput — пропускная
      способность)` — для максимизации пропускной способности
    * Бит `R (Reliability — надежность)` — для максимизации
      надежности доставки. Оставшиеся два бита имеют нулевое
      значение.

    * Стандарты дифференцированного обслуживания, принятые в конце 90-х, дали новое название этому полю, переопределив
      назначение его битов. В `DS-байте` также используются только старшие 6 бит, а два младших бита резервируются.
      `Об этом лучше не упоминать, тк вопроса про DS байты нет в экзамене`
* `Общая длина (2 байта)` - характеризует общую длину пакета с учетом заголовка и поля данных. Максимальная длина пакета
  ограничена разрядностью поля, определяющего эту величину, и составляет 65 535 байт, но в большинстве компьютеров и
  сетей столь большие пакеты не используются. _При передаче по сетям различного типа
  длина пакета выбирается с учетом максимальной длины пакета протокола нижнего уровня, несущего IP-пакеты._ `В стандартах TCP/IP
  предусматривается, что все хосты должны быть готовы принимать пакеты длиной вплоть
  до 576 байт (независимо от того, приходят они целиком или фрагментами).`
* `Идентификатор пакета (2 байта)` - используется для распознавания пакетов,
  образовавшихся путем деления на части (фрагментации) исходного пакета. Все части
  (фрагменты) одного пакета должны иметь одинаковое значение этого поля.
* `Флаги (3 байта)` - содержат признаки, связанные с фрагментацией.
    * `бит DF (Do not Fragment — не фрагментировать)` запрещает маршрутизатору
      фрагментировать данный пакет,
    * `бит MF (More Fragments — больше фрагментов)` говорит о том, что данный пакет является промежуточным (не
      последним)
      фрагментом.
    * Оставшийся бит зарезервирован.
* `Смещения фрагмента (13 бит)` задает смещение в байтах поля данных этого
  фрагмента относительно начала поля данных исходного (нефрагментированного) пакета. `Используется при сборке/разборке
  фрагментов пакетов. Смещение должно быть кратно 8 байтам.`
* `Время жизни (1 байт)` используется для задания
  предельного срока, в течение которого пакет может перемещаться по сети. Время жизни
  пакета измеряется в секундах и задается источником. Поскольку современные
  маршрутизаторы редко обрабатывают пакет дольше, чем за одну секунду, то время жизни
  можно интерпретировать как `максимальное число транзитных узлов`, которые разрешено
  пройти пакету. Если значение поля времени жизни становится нулевым до того, как пакет
  достигает получателя, то пакет уничтожается. `Таким образом, время жизни является своего
  рода часовым механизмом самоуничтожения пакета.`
* `Протокол верхнего уровная(1 байт)` одержит идентификатор, указывающий, какому протоколу верхнего уровня принадлежит
  информация, размещенная
  в поле данных пакета. Например, 6 означает, что
  в пакете находится сообщение протокола TCP, 17 — протокола UDP, 1 — протокола ICMP.

| **Значение** | **Протокол**                                       | **Описание**                                     |
  |--------------|----------------------------------------------------|--------------------------------------------------|
| 0            | Зарезервировано                                    | Используется для специальных целей.              |
| 1            | ICMP (Internet Control Message Protocol)           | Протокол управления сообщениями.                 |
| 2            | IGMP (Internet Group Management Protocol)          | Протокол управления группами.                    |
| 3            | GGP (Gateway-to-Gateway Protocol)                  | Протокол маршрутизации между шлюзами.            |
| 4            | IPv4 (encapsulation)                               | Инкапсуляция IPv4 в IPv4.                        |
| 5            | ST (Stream Protocol)                               | Протокол потоковой передачи.                     |
| 6            | TCP (Transmission Control Protocol)                | Надежный протокол передачи данных.               |
| 8            | EGP (Exterior Gateway Protocol)                    | Протокол внешнего шлюза.                         |
| 9            | IGP (Interior Gateway Protocol)                    | Протокол внутреннего шлюза.                      |
| 17           | UDP (User Datagram Protocol)                       | Ненадежный протокол передачи данных.             |
| 27           | RDP (Reliable Data Protocol)                       | Надежный протокол передачи данных.               |
| 41           | IPv6 (encapsulation)                               | Инкапсуляция IPv6 в IPv4.                        |
| 47           | GRE (Generic Routing Encapsulation)                | Протокол туннелирования.                         |
| 50           | ESP (Encapsulating Security Payload)               | Протокол обеспечения конфиденциальности (IPsec). |
| 51           | AH (Authentication Header)                         | Протокол аутентификации (IPsec).                 |
| 88           | EIGRP (Enhanced Interior Gateway Routing Protocol) | Улучшенный протокол маршрутизации.               |
| 89           | OSPF (Open Shortest Path First)                    | Протокол маршрутизации.                          |
| 115          | L2TP (Layer Two Tunneling Protocol)                | Протокол туннелирования уровня 2.                |
| 132          | SCTP (Stream Control Transmission Protocol)        | Протокол передачи сообщений.                     |
| 255          | Зарезервировано                                    | Для будущего использования.                      |

* `Контрольная сумма заголовка (2 байта)` рассчитывается только по заголовку. Поскольку некоторые поля заголовка меняют
  свое значение в процессе передачи
  пакета по сети (например, поле времени жизни), контрольная сумма проверяется и повторно рассчитывается на каждом
  маршрутизаторе и конечном узле как дополнение к сумме
  всех 16-битных слов заголовка. При вычислении контрольной суммы значение самого поля
  контрольной суммы устанавливается в ноль. Если контрольная сумма неверна, то пакет
  отбрасывается, как только обнаруживается ошибка.
* `Поля IP-адресов источника и приемника имеют одинаковую длину — 32 бита.`
* `Поле параметров является необязательным и используется обычно только при отладке
  сети.` Это поле состоит из нескольких подполей одного из восьми предопределенных типов. В этих подполях можно
  указывать точный маршрут, по которому маршрутизаторы
  должны направлять данный пакет (то есть выполнять `маршрутизацию от источника`),
  регистрировать проходимые пакетом маршрутизаторы или помещать данные системы
  безопасности и временные отметки. Так как число подполей в поле параметров может быть
  произвольным, то в конце заголовка должно быть добавлено несколько нулевых байтов
  для выравнивания заголовка пакета по 32-битной границе.

![Структура заголовка IP-пакета](img/img.png)

### Функции IP:

* _Поддержание интерфейса с нижележащими технологиями_ подсетей является одной из важнейших функций протокола IP. В эти
  функции входит
  также _поддержание интерфейса с протоколами вышележащего транспортного уровня_, в частности с протоколом TCP, который
  решает все вопросы обеспечения надежной доставки данных по составной сети в стеке TCP/IP.
* Большая часть действий протокола связана с обработкой той служебной информации, которая переносится в полях заголовка
  пакета.

## IP маршрутизация, упрощённая таблица маршрутизации, таблица маршрутизации конечного хоста

![Схема разбираемой сети](img/img_1.png)

Используя условные обозначения для сетевых адресов маршрутизаторов и номеров сетей,
показанные на рисунке выше, посмотрим, как могла бы выглядеть таблица маршрутизации, например, в маршрутизаторе 4.

| **Адрес назначения** | **Сетевой адрес следующего маршрутизатора** | **Сетевой адрес выходного порта** | **Расстояние до сети назначения** |
|----------------------|---------------------------------------------|-----------------------------------|-----------------------------------|
| N1                   | IP12 (R1)                                   | IP41                              | 1                                 |
| N2                   | –                                           | IP41                              | 0 (подсоединена)                  |
| N3                   | IP12 (R1)                                   | IP41                              | 1                                 |
| N4                   | IP21 (R2)                                   | IP41                              | 1                                 |
| N5                   | –                                           | IP42                              | 0 (подсоединена)                  |
| N6                   | IP21 (R2)                                   | IP21                              | 2                                 |
| IPv                  | IP21 (R2)                                   | IP41                              | 2                                 |
| Маршрут по умолчанию | IP51 (R5)                                   | IP42                              | –                                 |

Первый столбец таблицы содержит адреса назначения пакетов.

В каждой строке таблицы следом за адресом назначения указывается **сетевой адрес следующего маршрутизатора** (точнее,
сетевой адрес интерфейса следующего маршрутизатора),
на который надо направить пакет, чтобы тот передвигался по направлению к заданному
адресу по рациональному маршруту.

Перед тем как передать пакет следующему маршрутизатору, текущий маршрутизатор
должен определить, на какой из нескольких собственных портов (IP41 или IP42) он должен
поместить данный пакет. Для этого служит третий столбец таблицы маршрутизации, содержащий **сетевые адреса выходных
интерфейсов.**

Некоторые реализации сетевых протоколов допускают наличие в таблице маршрутизации
сразу нескольких строк, соответствующих одному и тому же адресу назначения. В этом
случае при выборе маршрута принимается во внимание столбец, представляющий расстояние до сети назначения. При этом
расстояние измеряется в любой метрике, используемой в соответствии с заданным в сетевом пакете критерием. В таблице
расстояние между сетями измеряется хопами. Расстояние для сетей, непосредственно подключенных
к портам маршрутизатора, здесь принимается равным 0, однако в некоторых реализациях
отсчет расстояний начинается с 1.

Когда пакет поступает на маршрутизатор, модуль IP извлекает из его заголовка номер
сети назначения и последовательно сравнивает его с номерами сетей из каждой строки
таблицы. Строка с совпавшим номером сети показывает ближайший маршрутизатор, на
который следует направить пакет. Чаще всего в качестве адреса назначения
в таблице указывается не весь IP-адрес, а только номер сети назначения. Таким образом,
для всех пакетов, направляемых в одну и ту же сеть, протокол IP будет предлагать один
и тот же маршрут.

> Однако в некоторых случаях возникает необходимость для одного из узлов сети определить
> **специфический маршрут**, отличающийся от маршрута, заданного для всех остальных узлов
> сети. Для этого в таблицу маршрутизации помещают для данного узла отдельную строку, содержащую его полный IP-адрес и
> соответствующую маршрутную информацию.

Такого рода запись имеется в таблице для узла В. Предположим, администратор маршрутизатора 4, руководствуясь
соображениями безопасности, решил направить пакеты,
следующие в узел B (полный адрес IPB), через маршрутизатор 2 (интерфейс IP21), а не
маршрутизатор 1 (интерфейс IP12), через который передаются пакеты всем остальным
узлам сети N3. Если в таблице имеются записи о маршрутах как к сети в целом, так и к ее
отдельному узлу, то при поступлении пакета, адресованного данному узлу, маршрутизатор
отдаст предпочтение специфическому маршруту.

Поскольку пакет может быть адресован в любую сеть составной сети, может показаться,
что каждая таблица маршрутизации должна иметь записи обо всех сетях, входящих в составную сеть. Однако при таком подходе
в случае крупной сети объем таблиц маршрутизации может оказаться очень большим, что повлияет на время ее просмотра,
потребует
много места для хранения и т. п. Поэтому на практике широко известен прием уменьшения количества записей в таблице
маршрутизации, основанный на введении маршрута
по умолчанию (default route), учитывающего особенности топологии сети. Рассмотрим,
например, маршрутизаторы, находящиеся на периферии составной сети. В их таблицах
достаточно записать номера только тех сетей, которые непосредственно подсоединены
к данному маршрутизатору или расположены поблизости на тупиковых маршрутах. Обо
всех остальных сетях можно сделать в таблице единственную запись, указывающую на
маршрутизатор, через который пролегает путь ко всем этим сетям. Такой маршрутизатор
называется маршрутизатором по умолчанию (default router). В нашем примере на маршрутизаторе 4 имеются специфические
маршруты только для пакетов, следующих в сети
N1–N6. Для всех остальных пакетов, адресованных в сети N7–N18, маршрутизатор предлагает продолжить путь через один и тот
же порт IP51 маршрутизатора 5, который в данном
случае и является маршрутизатором по умолчанию.

## IP маршрутизация: без масок, на основе масок

Протокол IP извлекает из пакета IP-адрес назначения (предположим, адрес назначения IPB).

1. Выполняется первая фаза просмотра таблицы — поиск специфического маршрута
   к узлу. IP-адрес (целиком) последовательно, строка за строкой, сравнивается с содержимым поля адреса назначения
   таблицы маршрутизации. Если произошло совпадение
   (как в табл. 14.1), то из соответствующей строки извлекаются адрес следующего маршрутизатора (IP21) и идентификатор
   выходного интерфейса (IP41). На этом просмотр
   таблицы заканчивается.
2. Предположим теперь, что в таблице нет строки с адресом назначения IPB, а значит,
   совпадения не произошло. В этом случае протокол IP переходит ко второй фазе просмотра — поиску маршрута к сети
   назначения. Из IP-адреса выделяется номер сети
   (в нашем примере из адреса IPB выделяется номер сети N3), после чего таблица снова
   просматривается на предмет совпадения номера сети в какой-либо строке с номером
   сети из пакета. При совпадении (а в нашем примере оно произошло) из соответствующей строки таблицы извлекаются адрес
   следующего маршрутизатора (IP12) и идентификатор выходного интерфейса (IP41). Просмотр таблицы на этом завершается.
3. Наконец, предположим, что адрес назначения в пакете был таков, что совпадения не
   произошло ни в первой, ни во второй фазах просмотра. В таком случае средствами
   протокола IP либо выбирается маршрут по умолчанию (и пакет направляется по
   адресу IP51), либо, если маршрут по умолчанию отсутствует, пакет отбрасывается.
   Просмотр таблицы на этом заканчивается.

#### ВНИМАНИЕ

> Последовательность фаз в данном алгоритме строго определена, в то время как последовательность
> просмотра или, что одно и то же, порядок расположения строк в таблице, включая запись о маршруте
> по умолчанию, никак не сказывается на результате.

## Схема протоколов модели OSI

## Протокол ICMP, структура кадра, типы сообщений, коды ошибок

> `Протокол межсетевых управляющих сообщений (Internet Control Message Protocol, ICMP)`
> является вспомогательным протоколом, использующимся для диагностики и мониторинга сети.

Протокол ICMP также призван компенсировать ненадежность протокола IP, но несколько
иным образом. Он не предназначен для _исправления_ возникших при передаче пакета проблем: если пакет потерян, то ICMP не
может послать его заново.
> ICMP-пакет является средством оповещения отправителя о «несчастных случаях», произошедших с его
> пакетами.

Пусть, например, протокол IP, работающий на каком-либо маршрутизаторе, обнаружил, что пакет для дальнейшей передачи по
маршруту необходимо фрагментировать,
но в пакете установлен признак DF (не фрагментировать). В таком случае протокол IP,
прежде чем отбросить пакет, отправляет диагностическое ICMP-сообщение конечному
узлу-источнику. ICMP-сообщение передается по сети в поле данных IP-пакета. IP-адрес
узла-источника определяется из заголовка исходного пакета, вызвавшего инцидент.

> Важно, что обработка ICMP-сообщений не входит в обязанности протоколов IP и ICMP.

### Формат, типы и коды ICMP-сообщений

Особенностью протокола ICMP является функциональное разнообразие решаемых задач,
а следовательно, и связанных с этим сообщений. Все типы сообщений имеют один и тот же
формат (рис. 14.14), однако интерпретация полей существенно зависит от того, к какому
типу относится сообщение.

![Формат ICMP-сообщения](img/img_2.png)

Заголовок ICMP-сообщения состоит из 8 байт:
*тип (1 байт) — числовой идентификатор типа сообщения

* код (1 байт) — числовой идентификатор, более тонко дифференцирующий тип ошибки
* контрольная сумма (2 байта) — подсчитывается для всего ICMP-сообщения.

> Содержимое оставшихся 4 байт в заголовке и поле данных зависит от значений полей типа и кода.

На рис. 14.15 показана таблица основных типов ICMP-сообщений. Эти сообщения можно
разделить на две группы:

* сообщения об ошибках;
* сообщения запрос-ответ (отмечены в таблице темным фоном).

![Типы ICMP-сообщений](img/img_3.png)

Сообщения типа «запрос-ответ» связаны в пары: «эхо-запрос — эхо-ответ», «запрос маски — ответ маски», «запрос отметки
времени — ответ отметки времени». Важную роль
в работе маршрутизируемой сети играет пара сообщений «запрос маршрутизатора» (router
solicitation) и «объявление маршрутизатора» (router advertisement), которые позволяют
хостам и маршрутизаторам находить друг друга.

Сообщение об ошибках может быть вызвано
различными причинами: неверный адрес сети или конечного узла (код 0 или 1), отсутствие
на конечном узле-адресате необходимого протокола прикладного уровня (код 2 — «протокол недостижим») или открытого порта
UDP/TCP (код 3 — «порт недостижим»). Узел
(или сеть) назначения может быть также недостижим по причине временной неработоспособности аппаратуры или из-за того,
что маршрутизатор не имеет данных о пути к сети
назначения. Всего таблица содержит 15 кодов. Аналогичные таблицы кодов существуют
и для других типов сообщений об ошибках.

## Протоколы TCP/UDP мультиплексировени и демультиплексирование, сокеты

### Мультиплекирование и демультиплексирование приложений

Реализуемая протоколами TCP и UDP процедура распределения между прикладными процессами пакетов, поступающих от сетевого
уровня,
называется `демультиплексированием`.

Существует и обратная задача: данные, генерируемые разными приложениями, работающими на одном конечном узле, должны быть
переданы общему для всех них протокольному модулю IP для последующей отправки в сеть. Эту работу, называемую
`мультиплексированием`, тоже выполняют протоколы
TCP и UDP.

![Мультиплексирование и демультиплексирование на транспортном уровне](img/img_4.png)

### Сокеты

> Прикладной процесс однозначно определяется в пределах сети и в пределах отдельного компьютера парой (IP-адрес, номер
> порта), называемой сокетом (socket). Сокет, определенный
> IP-адресом и номером UDP-порта, называется UDP-сокетом, а IP-адресом и номером TCP-
> порта — TCP-сокетом.

После получения IP-пакета от протокола
канального уровня протокол IP анализирует содержимое заголовка этого пакета, после
чего заголовок отбрасывается, а «наверх» передается содержимое поля данных IP-пакета,
например UDP-дейтаграмма. Упрощение состоит в том, что вместе с содержимым поля данных на транспортный уровень
передается извлеченный из заголовка IP-адрес назначения,
который и используется для однозначной идентификации приложения.

## Протокол UDP, структура кадра

Протокол UDP, подобно IP, является дейтаграммным протоколом, реализующим так называемый ненадежный сервис `по
возможности`, который не гарантирует доставку сообщений
адресату.

Протокол UDP добавляет к каждому отдельному сообщению свой 8-байтный заголовок, формируя из этих сообщений собственные
протокольные единицы, называемые `UDP-дейтаграммами`, и передает их нижележащему
протоколу IP. В этом и заключаются его функции по _мультиплексированию данных._

![Работа протокола UDP на хосте-отправителе](img/img_5.png)

### Заголовок UDP состоит из четырех двухбайтных полей:

* номер UDP-порта отправителя;
* номер UDP-порта получателя;
* контрольная сумма;
* длина дейтаграммы.

Функции сводятся к простой передаче данных между прикладным и сетевым уровнями, а также
примитивному контролю искажений в передаваемых данных. При контроле искажений
протокол UDP только _диагностирует, но не исправляет ошибку._ Если контрольная сумма
показывает, что в поле данных UDP-дейтаграммы произошла ошибка, то протокол UDP
просто отбрасывает поврежденную дейтаграмму.

Работая на хосте-получателе, протокол UDP принимает от протокола IP извлеченные
из пакетов UDP-дейтаграммы. Полученные из IP-заголовка IP-адрес назначения и из
UDP-заголовка номер порта используются для формирования UDP-сокета, однозначно
идентифицирующего приложение, которому направлены данные. Протокол UDP освобождает дейтаграмму от UDP-заголовка.
Полученное в результате сообщение он передает
приложению на соответствующий UDP-сокет. Таким образом, протокол UDP выполняет
_демультиплексирование_ на основе сокетов.

## Протокол TCP, структура кадра, схема логического содеинения в TCP

> Протокол TCP предназначен для передачи данных между приложениями. Этот протокол основан
> на логическом соединении, что позволяет ему обеспечивать гарантированную доставку данных,
> используя в качестве инструмента ненадежный дейтаграммный сервис протокола IP.

При работе на хосте-отправителе протокол TCP рассматривает информацию, поступающую к нему от прикладных процессов, как
_неструктурированный_ поток байтов.

Поступающие данные буферизуются средствами TCP. Для передачи на сетевой уровень из
буфера «вырезается» некоторая непрерывная часть данных, которая называется `сегментом`
и снабжается заголовком.

![Формирование TCP-сегментов из потока байтов](img/img_6.png)

Формат заголовка TCP-сегмента:

![Формат заголовка TCP-сегмента](img/img_7.png)

### Примечание

> В отличие от протокола UDP, создающего дейтаграммы на основе логически обособленных единиц
> данных (сообщений, генерируемых приложениями), протокол TCP делит поток данных на сегменты
> без учета их смысла или внутренней структуры.


Значение однобитных полей, называемых **флагами**, или **кодовыми
битами** (code bits). Они расположены сразу за резервным полем и содержат служебную
информацию о типе данного сегмента. Положительное значение сигнализируется установкой этих битов в единицу:

* `URG` — срочное сообщение;
* ``ACK`` — квитанция на принятый сегмент;
* `PSH` — запрос на отправку сообщения без ожидания заполнения буфера;
* `RST` — запрос на сброс соединения;
* `SYN` — сообщение, используемое для синхронизации счетчиков переданных данных при установлении соединения;
* ``FIN`` — признак достижения передающей стороной последнего байта в потоке передаваемых данных.

## Протокол TCP, схeма состояний

Соединение устанавливается по инициативе клиентской части приложения. При необходимости выполнить обмен данными с
серверной частью приложение-клиент обращается
к нижележащему протоколу TCP, который в ответ на это обращение посылает сегмент запрос на установление соединения
протоколу TCP, работающему на стороне сервера. В числе прочего в запросе содержится флаг SYN, установленный в 1.

![Процедура установления и разрыва логического соединения при нормальном течении процесса](img/img_8.png)

Получив запрос, модуль TCP на стороне сервера пытается создать «инфраструктуру» для обслуживания нового клиента. Он
обращается к ОС с просьбой о выделении
определенных системных ресурсов для организации буферов, таймеров, счетчиков.
Эти ресурсы закрепляются за соединением с момента создания и до момента разрыва.
Если на стороне сервера все необходимые ресурсы были получены и все необходимые
действия выполнены, то модуль TCP посылает клиенту сегмент с флагами ``ACK`` и `SYN`.
В ответ клиент посылает сегмент с флагом ``ACK`` и переходит в состояние установленного логического соединения (
состояние
`ESTABLISHED`). Получив флаг `ACK`, сервер
также переходит в состояние `ESTABLISHED`. На этом процедура установления соединения заканчивается, и стороны могут
переходить к обмену данными. Соединение
может быть разорвано в любой момент по инициативе любой стороны. Для этого клиент
и сервер должны обменяться сегментами `FIN` и `ACK` в последовательности, показанной
на рис. 15.7, б (здесь инициатором является клиент). Соединение считается закрытым
по прошествии некоторого времени, в течение которого сторона-инициатор убеждается,
что ее завершающий сигнал `ACK` дошел нормально и не вызвал никаких «аварийных»
сообщений со стороны сервера.

> Логическое TCP-соединение однозначно идентифицируется парой сокетов, определенных для
> этого соединения двумя взаимодействующими процессами.

Для каждой пары клиент-сервер протоколом TCP создается _отдельное логическое соединение._


> Протокол TCP осуществляет демультиплексирование информации, поступающей на прикладной
> уровень, на основе _соединений процессов_ или, что одно и то же, на основе идентифицирующих
> эти процессы _пар сокетов._

## Классификация протоколов маршрутизации

### Проколы маршрутизации не требующие наличия _таблиц маршрутизации на маршрутизаторах_:

* Метод **Лавинной маршрутизации** заключается в том, что каждый маршрутизатор передает пакет всем своим
  непосредственным
  соседям, исключая тот, от которого его получил.

* **Маршрутизация от источника** (source routing). В этом случае отправитель помещает в пакет информацию о том, какие
  промежуточные маршрутизаторы должны участвовать в передаче пакета к сети назначения. На основе этой информации каждый
  маршрутизатор считывает адрес следующего маршрутизатора, и если он действительно является адресом его
  непосредственного соседа, то передает ему пакет для дальнейшей обработки. Маршрут может задавать либо вручную
  администратор, либо автоматически узел-отправитель, но в этом случае ему нужно поддерживать какой-либо протокол
  маршрутизации, который сообщит ему о топологии и состоянии сети.

### Протоколы маршрутизации требующие наличия таблиц маршрутизации на маршрутизаторах:

Выбор рационального маршрута может осуществляться на основании различных _критериев_. Сегодня в IP-сетях применяются
протоколы маршрутизации, в которых маршрут выбирается по критерию кратчайшего расстояния. При этом расстояние измеряется
в различных метриках. Чаще всего используется простейшая метрика — количество хопов, то есть количество маршрутизаторов,
которые нужно преодолеть пакету
до сети назначения. В качестве метрик применяются также пропускная способность и надежность каналов, вносимые ими
задержки и любые комбинации этих метрик.

Задачей протоколов маршрутизации является создание на всех маршрутизаторах _согласованных_ друг с другом таблиц
маршрутизации, то есть таких таблиц, которые обеспечат
доставку пакета от исходной сети в сеть назначения за конечное число шагов.
Различают протоколы, выполняющие статическую и адаптивную (динамическую) маршрутизацию.

* При **статической маршрутизации** все записи в таблице имеют неизменяемый, статический статус, что подразумевает
  бесконечный срок их жизни. Записи о маршрутах составляются и вводятся в память каждого маршрутизатора _вручную
  администратором сети_. При изменении состояния сети администратору необходимо срочно отразить эти изменения в
  соответствующих таблицах маршрутизации, иначе может произойти их рассогласование и сеть будет работать некорректно.

* При **адаптивной маршрутизации** все изменения конфигурации сети автоматически отражаются в таблицах маршрутизации
  благодаря _протоколам маршрутизации._ Эти протоколы собирают информацию о топологии связей в сети, что позволяет им
  оперативно отражать все текущие изменения. В таблицах маршрутизации при адаптивной маршрутизации обычно имеется
  информация об интервале времени, в течение которого данный маршрут будет оставаться действительным. Это время называют
  _временем жизни_ (TTL) маршрута. Если по истечении времени жизни существование маршрута не подтверждается протоколом
  маршрутизации, то он считается нерабочим, и пакеты по нему больше не посылаются.

### Протоколы адаптивной маршрутизации бывают распределенными и централизованными:

* При распределенном подходе все маршрутизаторы сети находятся в равных условиях, они находят маршруты и строят
  собственные таблицы маршрутизации, работая в тесной кооперации друг с другом, постоянно обмениваясь информацией о
  конфигурации сети.

* При централизованном подходе в сети существует один выделенный маршрутизатор, собирающий всю информацию о топологии и
  состоянии сети от других маршрутизаторов. На основании этих данных выделенный маршрутизатор (иногда называемый
  сервером маршрутов) строит таблицы маршрутизации для остальных маршрутизаторов сети, распространяя их затем по сети,
  чтобы каждый маршрутизатор получил собственную таблицу и в дальнейшем самостоятельно принимал решение о продвижении
  каждого пакета. Централизованный подход порождает более рациональные маршруты потоков, чем распределенный, так как
  решения принимаются на основе полной и непротиворечивой информации о топологии связей сети. Но его недостатком
  является плохая масштабируемость.

Из-за этого недостатка в Интернете доминировали и продолжают доминировать децентрализованные протоколы маршрутизации,
но их решения не всегда дают такие же рациональные маршруты, как решения центрального элемента, так как они основаны
на информации, полученной из третьих рук — от своих соседей, которые в свою очередь получили ее от своих соседей.

Еще одним недостатком распределенных протоколов маршрутизации является существование периодов нестабильной работы сети,
вызванной временной несогласованностью таблиц разных маршрутизаторов. Распределенному протоколу маршрутизации обычно
нужно некоторое время — **время конвергенции**, чтобы после нескольких итераций обмена служебной информацией все
маршрутизаторы сети внесли изменения в свои таблицы, в результате чего они снова стали бы согласованными. Отметим,
различные протоколы маршрутизации обладают разным _временем конвергенции._

> Применяемые сегодня в IP-сетях протоколы маршрутизации относятся к адаптивным распределенным протоколам, которые в
> свою очередь делятся на две группы:
> * дистанционно-векторные алгоритмы (Distance Vector Algorithm, DVA);
> * алгоритмы состояния связей (Link State Algorithm, LSA).

* В `дистанционно-векторных алгоритмах (DVA)` каждый маршрутизатор периодически и широковещательно рассылает по сети
  вектор, компонентами которого являются расстояния (дистанции), измеренные в той или иной метрике, от данного
  маршрутизатора до всех известных ему сетей. Пакеты протоколов маршрутизации обычно называют **объявлениями о
  расстояниях**, так как с их помощью маршрутизатор объявляет остальным маршрутизаторам известные ему сведения о
  конфигурации сети. Получив от некоторого
  соседа вектор расстояний до известных тому сетей, маршрутизатор наращивает компоненты вектора на величину расстояния
  от себя до данного соседа и дополняет вектор информацией об известных ему самому других сетях, о которых он узнал
  непосредственно (если они подключены к его портам) или из аналогичных объявлений других маршрутизаторов. Обновленное
  значение вектора маршрутизатор рассылает своим соседям. В конце концов каждый маршрутизатор получает через соседние
  маршрутизаторы информацию обо всех имеющихся в составной сети сетях и о расстояниях до них и выбирает из нескольких
  альтернативных маршрутов к каждой сети маршрут, обладающий наименьшим значением метрики. Маршрутизатор, передавший
  информацию о данном маршруте, отмечается в таблице маршрутизации как _следующий_ (next hop).

  > Дистанционно-векторные алгоритмы хорошо работают только в небольших сетях. В больших сетях они периодически засоряют
  линии связи интенсивным трафиком, к тому же изменения конфигурации не всегда корректно могут отражаться алгоритмом
  этого типа, так как маршрутизаторы не имеют точного представления о топологии связей в сети, а располагают только
  косвенной информацией — вектором расстояний.

* Алгоритмы состояния связей (LSA) обеспечивают каждый маршрутизатор информацией, достаточной для построения точного
  графа связей сети. Все маршрутизаторы работают на основании одного и того же графа, что делает процесс маршрутизации
  более устойчивым к изменениям конфигурации. Каждый маршрутизатор использует граф сети для нахождения оптимальных по
  некоторому критерию маршрутов до каждой из сетей, входящих в составную сеть. Чтобы понять, в каком состоянии находятся
  линии связи, подключенные к его портам, маршрутизатор периодически обменивается короткими пакетами HELLO со своими
  непосредственными соседями. В отличие от протоколов DVA, которые регулярно передают вектор расстояний, протоколы LSA
  ограничиваются короткими сообщениями, а передача более объемных сообщений происходит только в тех случаях, когда с
  помощью сообщений HELLO был установлен факт изменения состояния какой-либо связи.

  > Cлужебный трафик, создаваемый протоколами LSA, гораздо менее интенсивный, чем у протоколов DVA. Протоколами,
  основанными на алгоритме состояния связей, являются протокол IS-IS стека OSI (этот протокол используется также в стеке
  TCP/IP) и протокол OSPF стека TCP/IP.

## Протокол RIP, время жизни пакетов, зацикливание пакетов

`Протокол маршрутной информации RIP (Routing Information Protocol)` является протоколом маршрутизации
дистанционно-векторного типа и чаще всего используется в небольших сетях. Для IP-сетей имеются две версии RIP — RIPv1 (
не поддерживает маски) и RIPv2(поддерживает маски). Так как способ построения таблиц маршрутизации в обеих версиях
протокола принципиально не отличается.

Для измерения расстояния до сети стандарты протокола RIP допускают различные метрики: хопы, значения пропускной
способности, вносимые задержки, надежность сетей (то есть соответствующие признакам D, T и R в поле качества сервиса
IP-пакета), а также любые комбинации этих метрик. Метрика должна обладать свойством аддитивности — метрика составного
пути должна быть равна сумме метрик составляющих этого пути. В большинстве реализаций RIP используется простейшая
метрика — количество хопов, то есть количество промежуточных маршрутизаторов, которые нужно преодолеть пакету до сети
назначения.

Таблица маршрутизации в протоколе RIP строится следующим образом:

Основные этапы:

1. Создание минимальной таблицы маршрутизации:

    * На этапе инициализации каждый маршрутизатор создает минимальную таблицу, содержащую записи только для сетей,
      непосредственно подключенных к нему. Эти данные автоматически добавляются в таблицу маршрутизации.

2. Рассылка минимальной таблицы соседям:

    * Каждый маршрутизатор передает информацию о своих известных маршрутах соседним маршрутизаторам. Информация включает
      IP-адрес сети и расстояние до нее (в хопах). Например, маршрутизатор R1 передает маршрутизаторам R2 и R3 данные о
      своих подключенных сетях с расстоянием 1.

3. Получение сообщений от соседей и обработка данных:

    * После получения сообщений RIP от соседей маршрутизатор обновляет свои таблицы маршрутизации. Каждое новое
      расстояние до сети увеличивается на 1 хоп, и информация сравнивается с уже существующей. Если новая метрика
      лучше (
      меньшее расстояние), она заменяет старую запись.

4. Рассылка обновленных таблиц маршрутизации:

    * После обработки информации маршрутизатор отправляет обновленную таблицу всем соседям. Процесс повторяется, пока
      все
      маршрутизаторы в сети не получат актуальную информацию обо всех доступных сетях.

5. Корректировка и удаление устаревших записей:

    * Для обеспечения актуальности таблиц маршрутизации используется механизм “истечения времени жизни маршрута”. Если в
      течение установленного времени (180 секунд) не поступает подтверждений о маршруте, запись считается
      недействительной
      и удаляется из таблицы.

Пример:

Для маршрутизатора R1 минимальная таблица может выглядеть так:

* Сеть: 201.36.14.0, Следующий маршрутизатор: 201.36.14.3, Расстояние: 1 хоп.

В процессе обмена данными таблица будет дополнена маршрутами к другим сетям через соседние маршрутизаторы, а также
оптимизирована для выбора кратчайших путей.

### Проблема зацикливания

Зацикливание пакетов в RIP возникает, когда информация о недоступности маршрута распространяется медленно из-за
особенностей протокола, что может привести к тому, что маршрутизаторы продолжают направлять трафик через устаревшие
маршруты. Это может привести к формированию маршрутных петель, в которых пакеты циркулируют бесконечно между
маршрутизаторами.

Пример:

* Если маршрутизатор R1 обнаруживает, что его связь с сетью 201.36.14.0 потеряна, он помечает сеть как недоступную.
  Однако до того, как R1 передаст эту информацию соседям, маршрутизатор R2 может отправить R1 устаревшую информацию,
  считая, что путь к сети 201.36.14.0 доступен через себя. R1 обновляет таблицу, основываясь на этой неверной
  информации,
  и зацикливание продолжается

### Механизмы предотвращения зацикливания в RIP

Чтобы минимизировать вероятность зацикливания и его последствия, в RIP применяются следующие методы:

1. Ограничение максимального расстояния (15 хопов):
    * Если расстояние до сети становится больше 15, сеть считается недоступной. Это ограничивает продолжительность
      циркуляции пакетов, так как зацикливание невозможно для недостижимых маршрутов
2. Split Horizon (разделение горизонта):
    * Маршрутизатор не отправляет информацию о маршруте тому соседу, от которого эта информация была получена. Это
      предотвращает “обратную волну” ложной информации
3. Poison Reverse (ядовитый маршрут):
    * Если маршрут становится недоступным, маршрутизатор отправляет соседям обновление с метрикой, равной 16 (
      бесконечность), что предотвращает использование данного маршрута
4. Holddown Timer (замораживание изменений):
    * При выявлении изменения состояния маршрута он “замораживается” на определенный интервал времени, предотвращая
      принятие новых обновлений от соседей. Это снижает вероятность добавления ложной информации в таблицы
5. Triggered Updates (триггерные обновления):
    * Вместо ожидания очередного цикла отправки таблиц маршрутизации (30 секунд), RIP немедленно отправляет обновление
      при обнаружении изменения состояния сети. Это позволяет быстрее уведомлять соседей о проблемах

## Протокол BGP

`Пограничный (внешний) шлюзовой протокол (Border Gateway Protocol, BGP)` в версии 4
является сегодня основным протоколом обмена маршрутной информацией между автономными системами Интернета. BGP успешно
работает при любой топологии связей между
автономными системами, что соответствует современному состоянию Интернета.

Маршрутизатор взаимодействует с другими маршрутизаторами по протоколу BGP только
в том случае, если администратор _явно_ указывает при конфигурировании, что эти маршрутизаторы являются его _соседями_.

Для установления сеанса с указанными соседями маршрутизаторы BGP используют протокол TCP (порт 179). При установлении
BGP-сеанса могут применяться разнообразные
способы аутентификации маршрутизаторов, повышающие безопасность работы автономных систем. Основное сообщение протокола
BGP — сообщение UPDATE (обновить),
с помощью которого маршрутизатор сообщает маршрутизатору соседней автономной
системы о достижимости сетей, относящихся к его собственной автономной системе.
Само название этого сообщения говорит о том, что это триггерное объявление, посылаемое соседу, если в топологии
автономной системы происходят изменения: появляются
новые сети или новые пути к сетям либо же, напротив, исчезают существовавшие сети
или пути. В одном сообщении UPDATE можно объявить об одном новом маршруте или
аннулировать несколько маршрутов, переставших существовать. Под маршрутом в BGP
понимается последовательность автономных систем, которую нужно пройти на пути
к указанной в адресе сети. Формальная запись о маршруте (BGP Route) к сети (Network/
Mask_length) выглядит так:

`BGP Route = AS_Path; NextHop; Network/Mask_length;`

Здесь AS_Path — набор номеров автономных систем, NextHop — IP-адрес маршрутизатора, через который нужно передавать
пакеты в сеть Network/Mask_length.

Отличия iBGP(Interior BGP, внутренняя версия BGP) и eBGP(Exterior BGP, внешняя версия BGP):

1. Область применения:
    * iBGP: используется внутри одной автономной системы (AS). Его задача — распространение информации о внешних
      маршрутах между маршрутизаторами внутри AS.
    * eBGP: используется для обмена маршрутами между разными автономными системами. Он отвечает за передачу информации о
      доступных сетях и политик маршрутизации между AS.
2. Формирование маршрутов:
    * В iBGP маршрутизаторы передают информацию друг другу без изменений. При этом маршрутизатор не изменяет AS_Path (
      последовательность автономных систем, через которые проходит маршрут).
    * В eBGP маршрутизатор добавляет номер своей автономной системы в AS_Path перед отправкой информации соседу. Это
      помогает избежать зацикливания маршрутов.
3. Режимы работы и требования:
    * iBGP требует установки соединения между всеми маршрутизаторами внутри AS (полнографовой топологии) либо применения
      таких решений, как маршрутизаторы Route Reflector.
    * eBGP предполагает прямое взаимодействие между маршрутизаторами на границе автономных систем.
4. Протоколы взаимодействия:
    * iBGP интегрируется с внутренними протоколами маршрутизации (например, OSPF, IS-IS), которые обеспечивают доставку
      пакетов внутри AS.
    * eBGP используется исключительно для межсетевых взаимодействий, определяя пути на основе политик и договоренностей
      между автономными системами.

## Общие принципы построения служб

## URI, URL, URN

### URL

Браузер находит веб-страницы и отдельные объекты по адресам специального формата,
называемым `URL`
(Uniform Resource Locator — унифицированный указатель ресурса).

URL-адрес может выглядеть, например, так: http://www.olifer.co.uk/books/books.htm. В URL- адресе можно выделить три
части:

* Тип протокола доступа. Помимо HTTP, здесь могут быть указаны и другие протоколы, такие как FTP, telnet, также
  позволяющие осуществлять удаленный доступ к файлам или компьютерам. Тем не менее основным протоколом доступа к
  веб-страницам является HTTP.
* DNS-имя сервера. Это имя сервера, на котором хранится нужная страница. В нашем случае — это имя
  сайта www.olifer.co.uk.
* Путь к объекту. Обычно это составное имя файла (объекта) относительно главного каталога веб-сервера, предлагаемого по
  умолчанию. В нашем случае главным каталогом является /books/books.htm. По расширению файла мы можем сделать вывод о
  том, что это HTML-файл.

### URI

URI (Uniform Resource Identifier — унифицированный идентификатор ресурса)

URI — это строка символов, используемая для идентификации ресурса в Интернете. URI может быть как локатором (URL), так и
именем (URN), или сочетать в себе обе функции.

Пример URI: urn:isbn:0451450523

В URI можно выделить следующие части:

* Схема: определяет тип идентификатора и указывает, как интерпретировать оставшуюся часть URI. В данном примере схема —
  urn, что означает, что используется унифицированное имя ресурса.
* Идентификатор пространства имен (NID): указывает на конкретное пространство имен, в рамках которого уникально
  идентифицируется ресурс. В данном случае — isbn, что относится к Международному стандартному книжному номеру.
* Специфичный для пространства имен компонент (NSS): уникальный идентификатор ресурса в рамках указанного пространства
  имен. В данном примере — 0451450523, что является конкретным ISBN книги.

## URN

URN (Uniform Resource Name — унифицированное имя ресурса)

URN — это тип URI, который служит для постоянной, независимой от местоположения идентификации ресурса. В отличие от URL,
URN не предоставляет информации о том, как найти или получить доступ к ресурсу; он лишь однозначно идентифицирует его.

Пример URN: urn:ietf:rfc:2648

В этом URN:

* Схема: urn
* Идентификатор пространства имен (NID): ietf, указывающий на пространство имен Интернет-инженерной рабочей группы.
* Специфичный для пространства имен компонент (NSS): rfc:2648, что ссылается на документ RFC 2648.

Сравнение URI, URL и URN

* URI: универсальный идентификатор ресурса, который может быть как локатором (URL), так и именем (URN), или сочетать обе
  функции.
* URL: подмножество URI, которое предоставляет способ нахождения ресурса, описывая его местоположение в сети и способ
  доступа к нему.
* URN: подмножество URI, которое предоставляет уникальное и постоянное имя ресурса без указания его местоположения или
  способа доступа.

Таким образом, каждый URL и URN является URI, но не каждый URI является URL или URN.

## Протокол HTTP, веб-клиент, веб-сервер, заголовки, cookie

> Клиентская часть веб-службы, или веб-клиент, называемый также браузером, представляет собой приложение, которое
> устанавливается на компьютере конечного пользователя и предназначено для просмотра веб-страниц.

Одной из важных функций браузера является _поддержание графического пользовательского
интерфейса._ Через интерфейс пользователь получает доступ к широкому набору услуг,
главная из которых, конечно, «веб-серфинг», включающий поиск и просмотр страниц,
навигацию между уже просмотренными страницами, переход по закладкам и хранение
истории посещений. Помимо средств просмотра и навигации, веб-браузер предоставляет пользователю возможность
_манипулирования страницами:_ сохранение их в файле на
диске своего компьютера, вывод на печать, передача по электронной почте, контекстный
поиск в пределах страницы, изменение кодировки и формата текста, а также множество
других функций, связанных с представлением информации на экране и настройкой самого браузера.

> Веб-сервер — это программа, хранящая объекты локально в каталогах компьютера, на котором
> она запущена, и обеспечивающая доступ к этим объектам по URL-адресам. Наиболее популярными веб-серверами сейчас
> являются Apache и Microsoft Internet Information Server.


Как и любой другой сервер, веб-сервер должен быть постоянно в активном состоянии,
прослушивая _TCP-порт 80,_ являющийся назначенным портом протокола HTTP. С получением запроса от клиента сервер
устанавливает TCP-соединение и получает от клиента
имя объекта, например, в виде /books/books.htm, после чего находит в своем каталоге этот
файл, а также другие связанные с ним объекты, и отсылает их по TCP-соединению клиенту. Получив объекты от сервера,
веб-браузер отображает их на экране. После
отправки всех объектов страницы клиенту сервер разрывает с ним TCP-соединение. В дополнительные функции сервера входят
также аутентификация клиента и проверка прав
доступа данного клиента к данной странице.

### Протокол HTTP

HTTP (HyperText Transfer Protocol — протокол передачи гипертекста) — это протокол прикладного уровня, во многом
аналогичный протоколам FTP и SMTP. Существует несколько
версий этого протокола: HTTP 1.0, HTTP 1.1, HTTP/2 и HTTP/3.
Обмен сообщениями идет по обычной схеме «запрос-ответ». Клиент и сервер обмениваются _текстовыми_ сообщениями
стандартного
формата, то есть каждое сообщение представляет собой несколько строк обычного текста в кодировке ASCII. Для
транспортировки HTTP-сообщений служит протокол TCP. При этом TCP-соединения могут использоваться двумя разными
способами:

* `Долговременное соединение` — передача в одном TCP-соединении нескольких объектов,
  причем время существования соединения определяется при конфигурировании веб-службы.
* `Кратковременное соединение` — передача в рамках одного TCP-соединения только
  одного объекта.

Долговременное соединение, в свою очередь, может быть использовано двумя способами:

* `Последовательная передача запросов с простоями` — это способ, посредством которого новый запрос посылается только
  после
  получения ответа.
* `Конвейерная передача` — это более эффективный способ, в котором следующий за прос посылается до прибытия ответа на
  один
  или несколько предыдущих запросов(напоминает метод скользящего окна). Обычно по умолчанию степень параллелизма
  устанавливается на уровне 5–10, но у пользователя имеется возможность изменять этот параметр при конфигурировании
  клиента.

В версии HTTP 1.0 поддерживается только режим кратковременных соединений, когда
после передачи одного запроса и получения ответа TCP-соединение закрывается. Такой
режим полностью соответствует концепции сервера без сохранения состояния, а это, как
уже отмечалось, приводит к замедлению работы браузера и увеличению трафика из-за
частого выполнения процедуры трехэтапного установления TCP-соединения.

В версии HTTP 1.1 по умолчанию применяются постоянные соединения и конвейерный
режим. Соединение разрывается по инициативе либо браузера, либо сервера за счет отиспользует таймер неактивности
пользователя для того, чтобы разорвать соединение по
тайм-ауту и не тратить ресурсы памяти на неактивные соединения.

Версия HTTP/2 ускорила процесс построения веб-браузером веб-страницы, сохранив
в целом синтаксис и семантику сообщений версий HTTP 1.0 и 1.1. Ускорение достигается
за счет нескольких усовершенствований механизма передачи запросов и ответов между
веб-браузером и веб-сервером:

* вместо использования отдельных TCP-соединений для передачи каждого запроса и ответа, приводившего к простоям из-за
  того, что новый запрос не может быть послан без
  получения ответа, теперь используется одно TCP-соединение для мультиплексирования нескольких запросов, которые могут
  быть посланы практически одновременно;
* приоритезация запросов к веб-серверу, благодаря которой сервер знает, какой запрос более важен веб-браузеру для
  построения страницы;
* введение режима Server Push, при котором веб-сервер может передать веб-браузеру не только запрашиваемые ресурсы, но и
  те, которые, по мнению веб-сервера, скоро понадобятся веб-браузеру;
* компрессия заголовков сообщений HTTP, значительно сокращающая длину сообщения за счет компрессии таких потенциально
  длинных полей, как куки.

Новая версия HTTP/3 (не стандартизованная на момент написания книги) должна прийти
на смену HTTP/2, заменив протокол TCP на новый протокол QUIC, являющийся
транспортным протоколом, работающим поверх UDP, и более быстро, чем TCP, устанавливающая соединения и обрабатывающая
потерю и искажения данных. Протокол QUIC
первоначально был разработан компанией Google и уже применяется в браузере Chrome
этой компании.

### Формат HTTP-сообщений

В протоколе HTTP все сообщения состоят из текстовых строк. HTTP-сообщения бывают
двух типов — запросы и ответы, — имеющих единую обобщенную структуру, состоящую
из трех частей: обязательной стартовой строки, а также необязательных заголовков и тела
сообщения.

Стартовая строка запроса включает в себя
поле метода — это название операции, которая должна быть выполнена. Чаще всего в запросах используется метод `GET`, то
есть запрос объекта (именно он включен в наш пример
запроса).

* Метод `HEAD` аналогичен методу `GET`, но запрашиваются только метаданные заголовка
  HTML-страницы.
* Метод `POST` используется клиентом для отправки данных на сервер: сообщений электронной почты, ключевых слов в запросе
  поиска, веб-формы.
* Метод `PUT` используется клиентом для размещения некоторого объекта на сервере, на
  который указывает URL-адрес.
* Метод `DELETE` указывает серверу на то, что некоторый объект на сервере, определяемый
  URL-адресом, необходимо удалить.

![Методы HTTP](img/img_9.png)

Методы `GET` и `HEAD` считаются безопасными1 для сервера, так как они только передают
информацию клиенту, а методы `POST`, `PUT` и `DELETE` — опасными, поскольку передают
информацию на сервер. Наибольшую угрозу представляют два последних метода, так как
они непосредственно указывают на объект на сервере. Используя эти методы, злоумышленник может атаковать сервер, заменяя
или удаляя некоторые его объекты.
В стартовой строке ответа, помимо уже упоминавшегося указания на версию протокола HTTP, имеется поле кода состояния и
поле фразы для короткого текстового сообщения,
поясняющего данный код пользователю. В настоящее время стандарты определяют пять
классов кодов состояния:

* `1xx` — информация о процессе передачи;
* `2xx` — информация об успешном принятии и обработке запроса клиента (в таблице в примере стартовой строки ответа
  приведен код и соответствующая фраза 200 OK, сообщающий клиенту, что его запрос успешно обработан);
* `3xx` — информация о том, что для успешного выполнения операции нужно произвести
  следующий запрос по другому URL-адресу, указанному в дополнительном заголовке
  Location;
* `4xx` — информация об ошибках со стороны клиента (читатель наверняка не раз сталкивался с ситуацией, когда при
  указании
  адреса несуществующей страницы браузер
  выводил на экран сообщение 404 Not Found);
* `5xx` — информация о неуспешном выполнении операции по вине сервера (например,
  сообщение 505 http Version Not Supported говорит о том, что сервер не поддерживает
  версию HTTP, предложенную клиентом).

Среди кодов состояния имеется код 401, сопровождаемый сообщением authorization
required. Если клиент получает такое сообщение в ответ на попытку доступа к странице
или объекту, это означает, что доступ к данному ресурсу ограничен и требует авторизации
пользователя.

### Cookie

**Куки (cookies — печенье)** представляет собой небольшой фрагмент текстовых данных, которым обмениваются веб-сервер и
браузер. Куки,
относящийся к некоторому сеансу браузера с сервером, содержит информацию о текущем
состоянии этого сеанса, аутентификационные данные и персональные настройки клиента,
а также уникальный для сервера номер сеанса. В течение всего сеанса куки сохраняется
_на стороне браузера._ При установлении соединения сервер генерирует содержимое куки
и передает его браузеру. Веб-браузер, получив текст куки от веб-сервера, сохраняет его
в виде файла. В течение всего сеанса пользователя, а возможно, и при всех повторных обращениях данного пользователя к
данному сайту, браузер передает куки серверу в том же
виде, в каком он его получил в последнем ответе сервера. Тем самым достигается эффект
запоминания состояния сеанса, причем состояние запоминается на стороне клиента.

Веб-сервер обычно применяет данные куки пользователя для его же (пользователя) удобства, например, интернет-магазины
обычно хранят в куки карту покупок пользователя,
в них также может храниться история навигации пользователя по страницам сайта. Типичной информацией, помещаемой
веб-сервером в куки, является идентификатор сеанса
пользователя (SID), на основе которого связываются воедино отдельные запросы пользователя. Даже в случае работы по
протоколу HTTP 1.1, который поддерживает длительные
TCP-сеансы, эти сеансы могут прерываться из-за временной неактивности пользователя,
так что объединение отдельных фрагментов сеанса (с тем, чтобы он представлялся пользователю единым) полезно для
индивидуального обслуживания пользователя.

Куки бывают _постоянными_ — они хранятся в файловой системе ОС и имеют длительные
сроки действия — и _временными_ — их браузер хранит в оперативной памяти и удаляет
после своего закрытия.

Куки имеют не только срок, но и _область действия_ — она задается доменным именем сайта,
который создал куки. Браузер не передает куки сайту с другим доменным именем, но так
как доменное имя может быть задано не для конкретного сайта, а для некоторого домена, то
есть, например, не для www.cisco.com, а для cisco.com, то куки могут иметь более широкую
область действия, чем один сайт.

## Протоколы TLS, SSL

Определение

* SSL (Secure Sockets Layer): Протокол, разработанный компанией Netscape Communications для защиты данных, передаваемых
  между клиентом (например, браузером) и сервером. SSL использует технологии, такие как шифрование, аутентификация и
  контроль целостности данных, обеспечивая защищенный канал связи.
* TLS (Transport Layer Security): Преемник SSL. Этот протокол был разработан как более безопасная альтернатива SSL, с
  улучшенными алгоритмами шифрования и новыми функциями. TLS обеспечивает защищенные соединения на уровне представления
  данных.

Основные функции протоколов

1. Взаимная аутентификация:

* Осуществляется путем обмена сертификатами, соответствующими стандарту X.509.
* Позволяет убедиться в подлинности обоих участников соединения.

2. Контроль целостности:

* Используются дайджесты для проверки, что данные не были изменены в процессе передачи.

3. Шифрование данных:

* Для обеспечения конфиденциальности используются симметричные ключи, которые генерируются на этапе “рукопожатия” и
  используются для шифрования всего последующего трафика.

Отличия TLS от SSL

1. Уровень безопасности:

* TLS использует более современные алгоритмы шифрования, такие как AES, а также улучшенные методы установления
  соединения (например, Elliptic Curve Cryptography).
* SSL, особенно версии 2.0 и 3.0, содержит уязвимости (например, атака POODLE), из-за чего эти версии больше не
  используются.

2. Эффективность:

* TLS более оптимизирован для работы с современными сетевыми протоколами, что снижает нагрузку на систему при
  установлении защищенного соединения.

3. Совместимость:

* TLS обратно совместим с SSL, но использование SSL в современных системах крайне нежелательно.

Применение

* Протоколы используются в HTTPS-соединениях, где HTTP работает поверх SSL или TLS. Например, при вводе
  адреса https://example.com браузер устанавливает защищенный канал связи с сервером, используя TLS.
* Протокол также может быть применен в других областях, таких как электронная почта (SMTP over TLS), VPN и файлообменные
  сервисы.

Заключение

SSL и TLS обеспечивают защиту данных, передаваемых через сеть. На сегодняшний день SSL заменен более безопасным
протоколом TLS. Современные системы должны использовать версии TLS 1.2 и 1.3 для обеспечения максимальной безопасности.

## Протокол FTP

### Определение

`FTP (File Transfer Protocol)` — это протокол прикладного уровня модели TCP/IP, предназначенный для передачи файлов
между клиентом и сервером в
сети. Он используется для доступа, передачи и управления файлами на удаленных системах, поддерживающих этот протокол.

### Как работает FTP

FTP функционирует по клиент-серверной модели. Клиент инициирует соединение и отправляет запросы, а сервер отвечает на
них. FTP использует два соединения:

1. Управляющее соединение: для передачи команд и статусов.
2. Данные: для передачи файлов.

### Заголовок протокола FTP

FTP, как протокол прикладного уровня, не имеет собственного заголовка в привычном понимании, так как он опирается на
функции транспортного уровня (TCP). Однако, структура взаимодействия включает:

1. Команды:
    * Текстовые команды, такие как USER, PASS, LIST, RETR, STOR.
    * Эти команды отправляются по управляющему каналу.
2. Коды ответа:
    * Сервер возвращает трехзначные коды ответа для обозначения состояния. Пример:
    * 200: успешное выполнение команды.
    * 530: отказ в доступе (требуется аутентификация).
    * 150: открытие соединения для передачи данных.
3. Формат передачи данных:
    * Данные передаются как потоки байтов, упакованные в TCP-сегменты.

### Пример работы FTP

1. Клиент вводит команду: ftp unix.mgu.com.
2. Клиент соединяется с сервером и передает команды:
    * `USER username` для передачи имени пользователя.
    * `PASS password` для ввода пароля.
3. После успешной аутентификации клиент использует команды:
    * `LIST:` просмотр содержимого директории.
    * `RETR filename`: скачивание файла.
    * `STOR filename`: загрузка файла на сервер.

### Применение FTP

FTP используется для:

* Загрузки и выгрузки файлов на серверы.
* Обмена большими объемами данных.
* Управления файлами на удаленных хостах.

### Современные аспекты

* `FTP` передает данные в открытом виде, что делает его небезопасным для использования в публичных сетях. Для защиты
  применяются:
* `FTPS (FTP Secure):` добавление SSL/TLS для шифрования.
* `SFTP (SSH File Transfer Protocol):` использование SSH для обеспечения безопасности передачи.

FTP остается важным инструментом в управлении данными и серверными операциями, особенно в частных сетях. Однако его
использование в открытых сетях требует дополнительного уровня защиты.

## Почтовая служба, протоколы POP и IMAP

## Протокол DNS

## Протоколы IPv5 и IPv6. Стркуктрура даресов IPv6

## Формат пакета IPv6

## Архитектура безпроводных сетей

## Стек протоколов и стандарты IEEE 802.11

## Формат кадра в стандарте IEEE 802.11

## Процедура присоединения устройств в IEEE 802.11

## Работа proxy и NAT

## Фаервол, основные функции, классификация

## Фаервол - схема настройки и фильтрации пакетов

## Определение и принципы работы WAF, NGFW, UTM

## Структура правила snort

## Атака TCP syn flood

## Атака TCP syn-ACK flood

## Атаки TCP rst\FIN flood

## Атака фраментированный ICMP\UDP flood, атака Ping Of Death

## Атака ARP-spoo FINg

